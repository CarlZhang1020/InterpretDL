import numpy as np

from tqdm import tqdm
from .abc_interpreter import InputGradientInterpreter
from ..data_processor.readers import preprocess_inputs, preprocess_save_path
from ..data_processor.visualizer import explanation_to_vis, show_vis_explanation, save_image


class SmoothGradInterpreterV2(InputGradientInterpreter):
    """

    Smooth Gradients method solves the problem of meaningless local variations in partial derivatives
    by adding random noise to the inputs multiple times and take the average of the
    gradients.

    More details regarding the Smooth Gradients method can be found in the original paper:
    http://arxiv.org/pdf/1706.03825.pdf
    """

    def __init__(self,
                 paddle_model,
                 use_cuda=None,
                 device='gpu:0',
                 model_input_shape=[3, 224, 224]):
        """

        Args:
            paddle_model (callable): A model with ``forward`` and possibly ``backward`` functions.
            device (str): The device used for running `paddle_model`, options: ``cpu``, ``gpu:0``, ``gpu:1`` etc.
            use_cuda (bool):  Would be deprecated soon. Use ``device`` directly.
            model_input_shape (list, optional): The input shape of the model. Default: [3, 224, 224]
        """
        
        InputGradientInterpreter.__init__(self, paddle_model, device, use_cuda)
        
        self.model_input_shape = model_input_shape
        self.data_type = 'float32'

    def interpret(self,
                  inputs,
                  labels=None,
                  noise_amount=0.1,
                  n_samples=50,
                  split=2,
                  visual=True,
                  save_path=None):
        """
        Main function of the interpreter. This passes the unit tests of test_cv and test_cv_class.

        Args:
            inputs (str or list of strs or numpy.ndarray): The input image filepath or a list of filepaths or numpy array of read images.
            labels (list or tuple or numpy.ndarray, optional): The target labels to analyze. The number of labels should be equal to the number of images. If None, the most likely label for each image will be used. Default: None
            noise_amount (float, optional): Noise level of added noise to the image.
                                            The std of Guassian random noise is noise_amount * (x_max - x_min). Default: 0.1
            n_samples (int, optional): The number of new images generated by adding noise. Default: 50
            visual (bool, optional): Whether or not to visualize the processed image. Default: True
            save_path (str or list of strs or None, optional): The filepath(s) to save the processed image(s). If None, the image will not be saved. Default: None

        :return: interpretations/gradients for each image
        :rtype: numpy.ndarray
        """

        imgs, data = preprocess_inputs(inputs, self.model_input_shape)
        # print(imgs.shape, data.shape, imgs.dtype, data.dtype)  # (1, 224, 224, 3) (1, 3, 224, 224) uint8 float32

        assert len(data) == 1, "interpret each sample individually, it is optimized."

        data_type = np.array(data).dtype
        self.data_type = data_type

        self._build_predict_fn(gradient_of='probability')

        # obtain the labels (and initialization).
        if labels is None:
            _, preds = self.predict_fn(data, None)
            labels = preds

        labels = np.array(labels).reshape((1, ))

        # SmoothGrad
        max_axis = tuple(np.arange(1, data.ndim))
        stds = noise_amount * (
            np.max(data, axis=max_axis) - np.min(data, axis=max_axis))

        data_noised = []
        for i in range(n_samples):
            noise = np.concatenate([
                np.float32(
                    np.random.normal(0.0, stds[j], (1, ) + tuple(d.shape)))
                for j, d in enumerate(data)
            ])
            data_noised.append(data + noise)
            
        data_noised = np.concatenate(data_noised, axis=0)
        # print(data_i.shape, labels.shape)
        # print(data_noised.shape)  # n_samples, 3, 224, 224

        # 2 splits, to avoid large GPU memory usage.
        if split == 2:
            split = n_samples // 2
            gradients_1, _ = self.predict_fn(data_noised[:split], np.repeat(labels, n_samples//2))
            gradients_2, _ = self.predict_fn(data_noised[split:], np.repeat(labels, n_samples - split))
            gradients = np.concatenate([gradients_1, gradients_2], axis=0)
        elif split == 3:
            split = n_samples // 3
            split2 = split * 2
            gradients_1, _ = self.predict_fn(data_noised[:split], np.repeat(labels, split))
            gradients_2, _ = self.predict_fn(data_noised[split:split2], np.repeat(labels, split))
            gradients_3, _ = self.predict_fn(data_noised[split2:], np.repeat(labels, n_samples - split2))
            gradients = np.concatenate([gradients_1, gradients_2, gradients_3], axis=0)
        else:
            # one split.
            gradients, _ = self.predict_fn(data_noised, np.repeat(labels, n_samples))

        avg_gradients = np.mean(gradients, axis=0, keepdims=True)
        # visualize and save image.
        if save_path is None and not visual:
            # no need to visualize or save explanation results.
            pass
        else:
            save_path = preprocess_save_path(save_path, 1)
            # print(imgs[i].shape, avg_gradients[i].shape)
            vis_explanation = explanation_to_vis(imgs[i], np.abs(avg_gradients[0]).sum(0), style='overlay_grayscale')
            if visual:
                show_vis_explanation(vis_explanation)
            if save_path[i] is not None:
                save_image(save_path[i], vis_explanation)

        # intermediate results, for possible further usages.
        self.labels = labels

        return avg_gradients
